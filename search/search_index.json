{"config": {"lang": ["fr"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"]}, "docs": [{"location": "", "title": "Cours de Premi\u00e8re NSI", "text": ""}, {"location": "#programme-du-cours", "title": "Programme du cours", "text": "<ol> <li>Constructions \u00e9l\u00e9mentaires</li> <li>Bool\u00e9ens</li> <li>Fonctions</li> <li>Cha\u00eenes de caract\u00e8res</li> <li>Tableaux</li> <li>p-uplets et dictionnaires</li> <li>Tables de donn\u00e9es</li> <li>Flottants</li> <li>Algorithmes classiques</li> </ol>"}, {"location": "#logiciels-a-installer", "title": "Logiciels \u00e0 installer", "text": "<p>Installation d'Anaconda</p> <p>La suite Anaconda, t\u00e9l\u00e9chargeable ici, contient l'\u00e9diteur de carnets Jupyter et l'\u00e9diteur de code Spyder.</p> <p></p>"}, {"location": "algos_classiques/", "title": "Chapitre 9 : Algorithmes classiques", "text": "<p>Page en construction...</p> <p></p>"}, {"location": "booleens/", "title": "Chapitre 2 : Bool\u00e9ens", "text": ""}, {"location": "booleens/#partie-a-valeurs-variables-et-expressions-booleennes", "title": "Partie A - Valeurs, variables et expressions bool\u00e9ennes", "text": ""}, {"location": "booleens/#definitions-et-premiers-exemples", "title": "D\u00e9finitions et premiers exemples", "text": "<p>Il existe deux valeurs bool\u00e9ennes, qui sont <code>Vrai</code> (en Python, <code>True</code> ou <code>1</code>) et <code>Faux</code> (en Python, <code>False</code> ou <code>0</code>).</p> <p>Une variable bool\u00e9enne est une variable dont la valeur est bool\u00e9enne et une expression bool\u00e9enne est une expression dont la valeur est bool\u00e9enne.</p> <p>Les expressions bool\u00e9ennes apparaissent dans la d\u00e9finition des instructions conditionnelles (<code>if expression_booleenne:</code>) et des boucles non born\u00e9es (<code>while expression_booleenne:</code>).</p> Exercice 2-01 : Variables et expressions bool\u00e9ennes <p>Objectif : Rep\u00e9rer les variables bool\u00e9ennes et les expressions bool\u00e9ennes dans un code.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> Activit\u00e9 2-02 : Conjecture de Syracuse <p>Objectifs :</p> <ul> <li>Retravailler les instructions conditionnelles et les boucles.</li> <li>Utiliser des expressions bool\u00e9ennes pour \u00e9tudier un probl\u00e8me math\u00e9matique c\u00e9l\u00e8bre.</li> </ul> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "booleens/#partie-b-operateurs-logiques-et-tables-de-verite", "title": "Partie B - Op\u00e9rateurs logiques et tables de v\u00e9rit\u00e9", "text": ""}, {"location": "booleens/#operateurs-logiques-non-et-ou-xor", "title": "Op\u00e9rateurs logiques non, et, ou, xor", "text": "<p>Nous avons vu comment utiliser des expressions bool\u00e9ennes simples telles que <code>n == 0</code>, <code>s != 1</code>, <code>-1 &lt;= n &lt;= 2</code> ou encore <code>s % 2 == 0</code>.</p> <p>Mais il est parfois n\u00e9cessaire d'\u00e9crire des expressions bool\u00e9ennes plus complexes, compos\u00e9es de plusieurs expressions bool\u00e9ennes reli\u00e9es entre elles pas des op\u00e9rateurs logiques. Nous utiliserons quatre op\u00e9rateurs en particulier : la n\u00e9gation (op\u00e9rateur non), la conjonction (op\u00e9rateur et), la disjonction inclusive (op\u00e9rateur ou) et la disjonction exclusive (op\u00e9rateur xor encore appel\u00e9 ou exclusif).</p> Op\u00e9rateur Nom commun Mot cl\u00e9 Python N\u00e9gation non <code>not</code> Conjonction et <code>and</code> Disjonction inclusive ou (ou inclusif) <code>or</code> Disjonction exclusive xor (ou exclusif) <code>^</code>"}, {"location": "booleens/#tables-de-verite", "title": "Tables de v\u00e9rit\u00e9", "text": "<p>Une table de v\u00e9rit\u00e9 est un tableau dans lequel apparait la valeur d'une expression bool\u00e9enne en fonction des valeurs prises par les variables bool\u00e9ennes contenues dans l'expression.</p> <p>On donne ci-dessous la table de v\u00e9rit\u00e9 des expressions <code>not A</code>, <code>A and B</code>, <code>A or B</code>, <code>A ^ B</code>.</p> <p>Table de v\u00e9rit\u00e9 des op\u00e9rateurs <code>non</code>, <code>et</code>, <code>ou</code> et <code>xor</code></p> nonetouxor, ou exclusif <p></p> <p></p> <p></p> <p></p> Exercice 2-03 : Table de v\u00e9rit\u00e9 d'expressions bool\u00e9ennes <p>Objectif : Dresser la table de v\u00e9rit\u00e9 d'une expression bool\u00e9enne d\u00e9pendant de deux ou trois variables bool\u00e9ennes.</p> <p>\u00c9nonc\u00e9</p> <p>1. <code>a</code> et <code>b</code> \u00e9tant deux variables bool\u00e9ennes, dresser la table de v\u00e9rit\u00e9 de l'expression <code>(not a) or (a and b)</code>.</p> <p>2. <code>a</code>, <code>b</code> et <code>c</code> \u00e9tant trois variables bool\u00e9ennes, dresser la table de v\u00e9rit\u00e9 de l'expression <code>(a or c) and (b or (not c))</code>.</p> Activit\u00e9 2-04 : Circuits logiques <p>Objectif : Comprendre comment un circuit logique peut repr\u00e9senter une expression bool\u00e9enne.</p> <p>\u00c9nonc\u00e9</p> <p>Un circuit logique est un dispositif \u00e9lectronique qui permet de r\u00e9aliser des op\u00e9rations bool\u00e9ennes en combinant des entr\u00e9es, des sorties et des portes logiques (li\u00e9es aux op\u00e9rateurs bool\u00e9ens). </p> <p>Un point donn\u00e9 du circuit ne peut avoir que deux \u00e9tats : <code>1</code> (correspondant \u00e0 un niveau haut de tension \u00e9lectrique) ou <code>0</code> (correspondant \u00e0 un niveau bas de tension \u00e9lectrique).</p> <p>L'utilisation d'un interrupteur en entr\u00e9e permet de passer d'un \u00e9tat \u00e0 l'autre et donc de mat\u00e9rialiser une variable bool\u00e9enne. L'utilisation d'une lampe en sortie permet de visualiser l'\u00e9tat.</p> <p>1. Identifier, dans chaque cas, quelle est l'entr\u00e9e et quelle est la sortie du circuit logique suivant :</p> <p></p> <p>On donne maintenant le circuit logique suivant dans lequel apparaissent quatre portes logiques reli\u00e9es chacune \u00e0 une lampe. On a utilis\u00e9 deux interrupteurs pour mat\u00e9rialiser deux variables bool\u00e9ennes en entr\u00e9e.</p> <p></p> <p>2. Simuler le fonctionnement de ce circuit sur le site Logic gate simulator en chargeant le fichier <code>portes_logiques.json</code> t\u00e9l\u00e9chargeable ici.</p> <p>3. En d\u00e9duire quelle porte logique est associ\u00e9e \u00e0 quel op\u00e9rateur bool\u00e9en.</p> <p>4. D\u00e9terminer une expression bool\u00e9enne correspondant \u00e0 la sortie du circuit logique ci-dessous. On appelle <code>a</code> la variable bool\u00e9enne associ\u00e9e \u00e0 l'interrupteur du bas et <code>b</code> celle associ\u00e9e \u00e0 l'interrupteur du haut.</p> <p></p> <p>5. Cr\u00e9er, sur le site Logic gate simulator, un circuit correspondant \u00e0 l'expression bool\u00e9enne <code>(a ^ b) or (not a and not b)</code>.</p> <p>6. Sur le m\u00eame sch\u00e9ma, ajouter un second circuit correspondant \u00e0 l'expression bool\u00e9enne <code>not (a and b)</code>.</p>"}, {"location": "booleens/#partie-c-exercices-et-activites", "title": "Partie C - Exercices et activit\u00e9s", "text": "Exercices 2-05 \u00e0 2-07 Exercice 2-05 : Identification d'un coupableExercice 2-06 : Table de v\u00e9rit\u00e9 et circuit logiqueExercice 2-07 : Simplification d'expressions bool\u00e9ennes <p>\u00c9nonc\u00e9</p> <p>Un vol de bijoux a \u00e9t\u00e9 commis et quatre hommes sont suspects. Un seul est coupable, un deuxi\u00e8me est son complice et les deux autres sont innocents.</p> <p>Voici le signalement des quatre suspects :</p> Nom du suspect Moustache Lunettes Cicatrice Boucle d'oreilles Donatello oui oui non non Leonardo oui non non oui Michelangelo non non oui oui Raffaello non oui oui non <p>Lors de leur interrogatoire, les suspects d\u00e9clarent :</p> <ul> <li>Donatello : \"Le coupable a une cicatrice ou une boucle d'oreille mais pas les deux !\"</li> <li>Leonardo : \"Le coupable a des lunettes !\"</li> <li>Michelangelo : \"Le coupable a une moustache ou des lunettes mais pas les deux !\"</li> <li>Raffaello : \"Le coupable n'a pas de cicatrice !\"</li> </ul> <p>Sachant que le coupable et son complice mentent et que les deux innocents disent la v\u00e9rit\u00e9, d\u00e9terminer qui est le coupable et qui est son complice.</p> Corrig\u00e9 <p>Le tableau ci-dessous indique, pour chaque coupable potentiel, quels suspects disent la v\u00e9rit\u00e9 ou mentent.</p> Nom du coupable potentiel T\u00e9moignage de Donatello T\u00e9moignage de Leonardo T\u00e9moignage de Michelangelo T\u00e9moignage de Raffaello Nombre de menteurs Donatello mensonge v\u00e9rit\u00e9 mensonge v\u00e9rit\u00e9 2 Leonardo v\u00e9rit\u00e9 mensonge v\u00e9rit\u00e9 v\u00e9rit\u00e9 1 Michelangelo mensonge mensonge mensonge mensonge 4 Raffaello v\u00e9rit\u00e9 v\u00e9rit\u00e9 v\u00e9rit\u00e9 mensonge 1 <p>La seule situation o\u00f9 il y a exactement deux menteurs est celle o\u00f9 Donatello est le coupable. Son complice est donc le second menteur, Michelangelo.</p> <p>\u00c9nonc\u00e9</p> <p>1. <code>a</code> et <code>b</code> et <code>c</code> \u00e9tant trois variables bool\u00e9ennes, dresser la table de v\u00e9rit\u00e9 de l'expression <code>(a ^ b) and (not a or c)</code>.</p> <p>2. Repr\u00e9senter l'expression de la question pr\u00e9c\u00e9dente sous forme de circuit logique sur le site Logic gate simulator.</p> <p>\u00c9nonc\u00e9</p> <p>Soient <code>a</code>, <code>b</code> et <code>c</code> trois variables bool\u00e9ennes.</p> <p>1. D\u00e9terminer une forme simplifi\u00e9e de l'expression bool\u00e9enne <code>a or (not a and b)</code>.</p> <p>2. M\u00eame question pour l'expression bool\u00e9enne <code>(a or b) and (a or not b)</code>.</p> <p>3. M\u00eame question pour l'expression bool\u00e9enne <code>(not a or b) and (a or b or c) and not c</code>.</p> Activit\u00e9s 2-08 \u00e0 2-10 Activit\u00e9 2-08 : Jeu de rapidit\u00e9 Boolean GameActivit\u00e9 2-09 : Additionneur 4 bitsActivit\u00e9 2-10 : Afficheur 7 segments <p>Objectif : S'entra\u00eener \u00e0 manipuler les op\u00e9rateurs logiques.</p> <p>Boolean Game</p> <p>Pouvez-vous d\u00e9passer les 40 points au jeu Boolean Game ?</p> <p>Objectifs :</p> <ul> <li>Comprendre le fonctionnement d'un circuit logique donn\u00e9.</li> <li>Comprendre comment un circuit logique permet d'additionner deux entiers.</li> </ul> <p>\u00c9nonc\u00e9</p> <p>1. Dresser la table de v\u00e9rit\u00e9 du demi-additionneur repr\u00e9sent\u00e9 ci-dessous, en indiquant la valeur des deux sorties en fonction de la valeur des deux entr\u00e9es.</p> <p>Il est possible de simuler le comportement du demi-additionneur sur le site Logic gate simulator en chargeant le fichier <code>demi_additionneur.json</code> t\u00e9l\u00e9chargeable ici.</p> <p></p> <p>2. En d\u00e9duire une justification du fait que le demi-additionneur permet d'additionner deux bits.</p> <p>3. Expliquer en quoi le circuit ci-dessous, appel\u00e9 additionneur complet, permet d'additionner trois bits.</p> <p>Il est possible de simuler le comportement de l'additionneur complet sur le site Logic gate simulator en chargeant le fichier <code>additionneur_complet.json</code> t\u00e9l\u00e9chargeable ici.</p> <p></p> <p>4. Sur le sch\u00e9ma de l'additionneur 4 bits ci-dessous, identifier :</p> <ul> <li>les deux entr\u00e9es compos\u00e9es de quatre bits chacune,</li> <li>les deux sorties : la premi\u00e8re compos\u00e9e de quatre bits, la seconde d'un bit unique (retenue),</li> <li>les quatre additionneurs complets utilis\u00e9s,</li> <li>les quatre retenues obtenues au cours du calcul.</li> </ul> <p></p> <p>5. Repr\u00e9senter en rouge les liaisons par lesquelles le courant passe lorsqu'on effectue l'addition <code>6 + 5</code>.</p> <p>6. M\u00eame question pour l'addition <code>12 + 5</code>.</p> <p>Objectifs :</p> <ul> <li>D\u00e9terminer des expressions bool\u00e9ennes \u00e0 partir de tables de v\u00e9rit\u00e9.</li> <li>Repr\u00e9senter des expressions bool\u00e9ennes sous forme de circuits logiques.</li> <li>Comprendre comment afficher un chiffre hexad\u00e9cimal sur un afficheur 7 segments.</li> </ul> <p>\u00c9nonc\u00e9</p> <p>Un afficheur 7 segments permet d'afficher un chiffre en activant ou d\u00e9sactivant chacun des sept segments qui le composent.</p> <p>Premi\u00e8re partie : cas des chiffres de 0 et 1</p> <p></p> <p>Les deux chiffres <code>0</code> et <code>1</code> se repr\u00e9sentent sur un seul bit, qu'on peut associer \u00e0 une variable bool\u00e9enne <code>a</code>.</p> <p><code>a</code> vaut <code>False</code> pour le chiffre <code>0</code>. <code>a</code> vaut <code>True</code> pour le chiffre <code>1</code>.</p> <p>1. D\u00e9terminer, en fonction de la valeur de <code>a</code>, si chacun des sept segments de l'afficheur doit \u00eatre activ\u00e9 ou pas.</p> <p>On peut cr\u00e9er un circuit logique qui illustre les sept expressions bool\u00e9ennes trouv\u00e9es \u00e0 la question pr\u00e9c\u00e9dente.</p> <p></p> <p>2. Simuler le comportement de ce circuit sur le site Logic gate simulator en chargeant le fichier <code>afficheur_1bit.json</code> t\u00e9l\u00e9chargeable ici.</p> <p>Deuxi\u00e8me partie : cas des chiffres de 0 \u00e0 3</p> <p></p> <p>Les quatre chiffres de <code>0</code> \u00e0 <code>3</code> se repr\u00e9sentent sur deux bits, qu'on peut associer \u00e0 deux variables bool\u00e9ennes : <code>a</code> pour le bit de poids fort et <code>b</code> pour le bit de poids faible.</p> <p>3. D\u00e9terminer, en fonction des valeurs de <code>a</code> et <code>b</code>, si chacun des sept segments de l'afficheur doit \u00eatre activ\u00e9 ou pas.</p> <p>On peut cr\u00e9er un circuit logique qui illustre les sept expressions bool\u00e9ennes trouv\u00e9es \u00e0 la question pr\u00e9c\u00e9dente.</p> <p></p> <p>4. Compl\u00e9ter ce circuit puis simuler son comportement sur le site Logic gate simulator apr\u00e8s avoir charg\u00e9 le fichier <code>afficheur_2bits_vierge.json</code> t\u00e9l\u00e9chargeable ici.</p> <p>Troisi\u00e8me partie : cas des seize chiffres hexad\u00e9cimaux</p> <p></p> <p>Les seize chiffres hexad\u00e9cimaux se repr\u00e9sentent sur quatre bits, qu'on peut associer \u00e0 quatre variables bool\u00e9ennes <code>a</code>, <code>b</code>, <code>c</code> et <code>d</code> : <code>a</code> pour le bit de poids le plus fort et <code>d</code> pour le bit de poids le plus faible.</p> <p>5. Apr\u00e8s avoir dress\u00e9 la table de v\u00e9rit\u00e9 de l'expression bool\u00e9enne <code>(a and d) or (c and (a or not b or not d)) or ((a ^ b) and not c)</code>, justifier que cette expression permet l'activation du segment central pour l'affichage des seize chiffres hexad\u00e9cimaux.</p> <p>6. D\u00e9terminer une expression bool\u00e9enne (en fonction des variables <code>a</code>, <code>b</code>, <code>c</code> et <code>d</code>) permettant l'activation du segment situ\u00e9 en bas \u00e0 gauche pour l'affichage des seize chiffres hexad\u00e9cimaux.</p>"}, {"location": "booleens/#ce-quil-faut-savoir-et-savoir-faire", "title": "Ce qu'il faut savoir et savoir faire", "text": "<ul> <li>Rep\u00e9rer variables bool\u00e9ennes et expressions bool\u00e9ennes dans un algorithme ou un programme.</li> <li>\u00c9crire une expression bool\u00e9enne complexe en utilisant les op\u00e9rateurs <code>non</code>, <code>et</code>, <code>ou</code>, <code>xor</code>.</li> <li>Donner la table de v\u00e9rit\u00e9 des op\u00e9rateurs <code>non</code>, <code>et</code>, <code>ou</code>, <code>xor</code>.</li> <li>Donner la table de v\u00e9rit\u00e9 d'une expression bool\u00e9enne complexe contenant des variables bool\u00e9ennes.</li> <li>Faire le lien entre une expression bool\u00e9enne complexe contenant des variables bool\u00e9ennes et un circuit de portes logiques.</li> <li>Utiliser les op\u00e9rateurs <code>//</code> (quotient de la division euclidienne), <code>%</code> (reste de la division euclidienne) et <code>**</code> (puissance).</li> <li>Mesurer le temps moyen d'ex\u00e9cution d'une cellule de carnet Jupyter \u00e0 l'aide de l'outil Time it.</li> </ul>"}, {"location": "chaines/", "title": "Chapitre 4 : Cha\u00eenes de caract\u00e8res", "text": ""}, {"location": "chaines/#partie-a-representation-dun-texte-en-machine", "title": "Partie A - Repr\u00e9sentation d'un texte en machine", "text": "<p>Pour stocker un texte dans la m\u00e9moire d'un ordinateur, pour transmettre un texte \u00e0 une imprimante, pour envoyer un email, etc., il est n\u00e9cessaire de pouvoir encoder ce texte sous forme de bits, en associant \u00e0 chaque caract\u00e8re du texte une s\u00e9quence de bits.</p> <p>Plusieurs difficult\u00e9s apparaissent. Il faut que les diff\u00e9rentes machines qui doivent manipuler le texte utilisent le m\u00eame encodage. Cet encodage doit permettre de repr\u00e9senter le plus grand nombre de caract\u00e8res diff\u00e9rents possible, dont un certain nombre de caract\u00e8res non imprimables qui permettent de signaler le d\u00e9but et la fin du texte, une nouvelle ligne, une tabulation, etc.. Enfin, il faut prendre garde que l'encodage ne n\u00e9cessite pas un trop grand nombre de bits pour chaque caract\u00e8re, faute de quoi le stockage en m\u00e9moire pourrait \u00eatre peu optimal.</p>"}, {"location": "chaines/#encodage-ascii", "title": "Encodage ASCII", "text": "<p>Dans les ann\u00e9es 60 est apparue la norme ASCII (American Standard Code for Information Interchange ou code am\u00e9ricain normalis\u00e9 pour l'\u00e9change d'information) qui permet d'encoder 128 caract\u00e8res sur 7 bits chacun :</p> <ul> <li>34 caract\u00e8res non imprimables (dont l'espace), cod\u00e9s de <code>0</code> \u00e0 <code>32</code> et <code>127</code>,</li> <li>10 chiffres indo-arabes, cod\u00e9s de <code>48</code> \u00e0 <code>57</code>,</li> <li>26 lettres latines majuscules, cod\u00e9es de <code>65</code> \u00e0 <code>90</code>,</li> <li>26 lettres latines minuscules, cod\u00e9es de <code>97</code> \u00e0 <code>122</code>,</li> <li>32 autres signes (ponctuation, symboles math\u00e9matiques, etc.), cod\u00e9s de <code>33</code> \u00e0 <code>47</code>, de <code>58`` \u00e0</code>64<code>`, de</code>91<code>\u00e0</code>96<code>et de</code>123<code>\u00e0</code>126`.</li> </ul> <p>Si <code>n</code> est un entier compris entre 33 et 126, alors l'expression <code>chr(n)</code> correspond au caract\u00e8re associ\u00e9 \u00e0 <code>n</code> dans l'encodage ASCII.</p> <p>Si <code>c</code> est un caract\u00e8re ASCII, alors l'expression <code>ord(c)</code> correspond \u00e0 l'entier associ\u00e9 au caract\u00e8re <code>c</code>.</p> Exercice 4-01 : Utilisation des fonctions <code>chr</code> et <code>ord</code> <p>Objectif : Travailler la correspondance entre caract\u00e8res et entiers.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Voici la table ASCII compl\u00e8te :</p> <p></p> <p>La norme ASCII permet d'\u00e9crire du texte en anglais, mais pas dans la tr\u00e8s grande majorit\u00e9 des autres langues puisque seuls les caract\u00e8res latins non accentu\u00e9s sont disponibles.</p>"}, {"location": "chaines/#encodages-iso-8859", "title": "Encodages ISO 8859", "text": "<p>L'Organisation Internationale de Normalisation (ISO) a propos\u00e9 seize extensions de la norme ASCII permettant de repr\u00e9senter 256 caract\u00e8res sur 8 bits chacun : c'est la norme ISO 8859.</p> <p>Les 128 premiers caract\u00e8res sont les m\u00eames que la norme ASCII. Les 128 derniers caract\u00e8res d\u00e9pendent de l'extension utilis\u00e9e. En particulier, l'encodage latin-1 (ISO 8859-1) permet d'\u00e9crire la plupart des langues d'Europe occidentale dont le fran\u00e7ais. D'autres encodages permettent d'\u00e9crire l'alphabet cyrillique (ISO 8859-5), arabe (ISO 8859-6), grec (ISO 8859-7), h\u00e9breu (ISO 8859-8), turc (ISO 8859-9).</p> <p>Si <code>n</code> est un entier compris entre 161 et 255, alors l'expression <code>chr(n)</code> correspond au caract\u00e8re associ\u00e9 \u00e0 <code>n</code> dans l'encodage latin-1.</p> <p>Si <code>c</code> est un caract\u00e8re latin-1, alors l'expression <code>ord(c)</code> correspond \u00e0 l'entier associ\u00e9 au caract\u00e8re <code>c</code>.</p>"}, {"location": "chaines/#encodage-unicode-utf-8", "title": "Encodage Unicode (UTF-8)", "text": "<p>L'encodage ISO 8859 permet d'\u00e9crire des textes dans plusieurs langues, mais pas d'\u00e9crire un texte compos\u00e9 d'un m\u00e9lange de caract\u00e8res de plusieurs langues. C'est pourquoi l'ISO a mis au point un jeu de caract\u00e8res universel (Universal Character Set) comprenant actuellement plus de 130 000 caract\u00e8res cod\u00e9s sur 21 bits, et qui pourrait th\u00e9oriquement en accueillir plus de quatre millions cod\u00e9s sur 32 bits. Les 256 premiers de ces caract\u00e8res sont les m\u00eames que ceux de la norme latin-1.</p> <p>Cependant, l'utilisation de trois \u00e0 quatre octets pour coder chaque caract\u00e8re est tr\u00e8s peu optimale puisque les caract\u00e8res latins accentu\u00e9s sont tous cod\u00e9s entre 0 et 255 (1 octet) et les autres caract\u00e8res les plus utilis\u00e9s dans le monde sont cod\u00e9s entre 0 et 65 535 (2 octets).</p> <p>La norme Unicode a \u00e9t\u00e9 mise au point pour rem\u00e9dier \u00e0 ce probl\u00e8me. L'encodage UTF-8 (Universal Transformation Format 8 bits) permet ainsi que chaque caract\u00e8re soit cod\u00e9 sur le moins d'octets possible, entre 1 et 4.</p> <p>Par d\u00e9faut, Python encode les cha\u00eenes de caract\u00e8res en UTF-8.</p> <p>Les fonctions <code>chr</code> et <code>ord</code> vues pr\u00e9c\u00e9demment permettent en r\u00e9alit\u00e9 d'associer un caract\u00e8re et un code dans l'encodage UTF-8.</p>"}, {"location": "chaines/#partie-b-operations-sur-les-chaines-de-caracteres", "title": "Partie B - Op\u00e9rations sur les cha\u00eenes de caract\u00e8res", "text": "<p>Une cha\u00eene de caract\u00e8res vide se note <code>''</code> ou <code>\"\"</code>.</p> <p>La fonction <code>len</code> renvoie la longueur de la cha\u00eene, c'est-\u00e0-dire son nombre de caract\u00e8res.</p> <p>Le caract\u00e8re num\u00e9ro <code>k</code> de <code>chaine</code> s'obtient via l'expression <code>chaine[k]</code>, sachant que les caract\u00e8res sont num\u00e9rot\u00e9s \u00e0 partir de <code>0</code>.</p> Exercice 4-XX : xxxxxxxxxxxxxxxxxxxxxx <p>Objectif : xxxxxxxxxxxxxxxxxxxxxxxxx</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "chaines/#partie-c-lecture-et-ecriture-dans-un-fichier", "title": "Partie C - Lecture et \u00e9criture dans un fichier", "text": ""}, {"location": "chaines/#partie-d-exercices-et-activites", "title": "Partie D - Exercices et activit\u00e9s", "text": ""}, {"location": "chaines/#ce-quil-faut-savoir-et-savoir-faire", "title": "Ce qu'il faut savoir et savoir faire", "text": "<ul> <li>Conna\u00eetre quelques caract\u00e9ristiques des encodages ASCII, ISO 8859 et Unicode.</li> <li>Parcourir les caract\u00e8res d'une cha\u00eene avec une boucle du type <code>for lettre in chaine:</code>.</li> <li>Concat\u00e9ner plusieurs cha\u00eenes de caract\u00e8res.</li> <li>\u00c9crire une cha\u00eene de caract\u00e8res format\u00e9e (f-string).</li> <li>Ouvrir un fichier en lecture ou en \u00e9criture, en pr\u00e9cisant l'encodage appropri\u00e9.</li> <li>Lire le contenu d'un fichier texte, en int\u00e9gralit\u00e9 ou ligne par ligne.</li> <li>\u00c9crire dans un fichier texte, en \u00e9crasant ou non le contenu pr\u00e9existant.</li> <li>Modifier la norme d'encodage un fichier texte.</li> <li>Utiliser les fonctions <code>chr</code> et <code>ord</code>.</li> <li>D\u00e9terminer le nombre de caract\u00e8res d'une cha\u00eene avec la fonction <code>len</code>.</li> <li>Acc\u00e9der au <code>k</code>\u00e8me caract\u00e8re d'une cha\u00eene avec l'expression <code>chaine[k]</code>.</li> <li>Utiliser les instructions <code>upper()</code> et <code>lower()</code> pour mettre tous les caract\u00e8res d'une cha\u00eene en majuscule ou minuscule.</li> </ul>"}, {"location": "constr_elem/", "title": "Chapitre 1 : Constructions \u00e9l\u00e9mentaires", "text": "Activit\u00e9 1-01 : Prise en main de Jupyter <p>Objectifs :</p> <ul> <li>Ex\u00e9cuter des cellules de carnet Jupyter et d\u00e9couvrir les boutons les plus utiles.</li> <li>Faire la diff\u00e9rence entre une expression et une instruction.</li> <li>Installer un certain nombre de modules compl\u00e9mentaires qui seront utilis\u00e9s dans la suite du cours de NSI.</li> </ul> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "constr_elem/#partie-a-variables-affectations-et-sequences-dinstructions", "title": "Partie A - Variables, affectations et s\u00e9quences d'instructions", "text": ""}, {"location": "constr_elem/#variables", "title": "Variables", "text": "<p>Une variable est une r\u00e9f\u00e9rence \u00e0 une zone de la m\u00e9moire de l'ordinateur dans laquelle est stock\u00e9e une valeur.</p> <p>Pour attribuer une valeur \u00e0 une variable ou pour modifier sa valeur, on r\u00e9alise une affectation.</p> <pre><code>x = 0\n</code></pre> <p>Une variable appel\u00e9e <code>x</code> a \u00e9t\u00e9 d\u00e9finie, et la valeur <code>0</code> a \u00e9t\u00e9 stock\u00e9e dans la variable gr\u00e2ce \u00e0 une affectation, not\u00e9e <code>=</code> en Python.</p> <p>Pour afficher \u00e0 l'\u00e9cran la valeur de la variable <code>x</code>, on utilise la fonction <code>print</code>.</p> <pre><code>print(x)\n</code></pre> <p>Attention aux noms de variables choisis</p> <p>Le nom d'une variable doit \u00eatre choisi de sorte que l'on comprenne rapidement le r\u00f4le de cette variable.</p> <p>Le nom peut contenir des lettres, des chiffres et certains caract\u00e8res sp\u00e9ciaux. Il doit commencer par une lettre minuscule.</p> <p>De plus, certains mots-cl\u00e9s du langage Python ne peuvent pas \u00eatre utilis\u00e9s comme nom de variable.</p>"}, {"location": "constr_elem/#sequences-dinstructions", "title": "S\u00e9quences d'instructions", "text": "<p>Le langage de programmation Python est un langage de programmation imp\u00e9rative. Cela signifie que les instructions sont ex\u00e9cut\u00e9es les unes apr\u00e8s les autres, dans l'ordre.</p> <p>Consid\u00e9rons par exemple la s\u00e9quence d'instructions suivante :</p> <pre><code>total = 0\nnote = 13\ntotal = total + note\nnote = 15\ntotal = total + note\nnote = 8\ntotal = total + note\nmoyenne = total / 3\n</code></pre> <ul> <li> <p>Ligne <code>1</code> : On d\u00e9finit une variable <code>total</code> en lui affectant la valeur <code>0</code>. Cette \u00e9tape s'appelle l'initialisation de la variable.</p> </li> <li> <p>Ligne <code>2</code> : On initialise une variable <code>note</code> en lui affectant la valeur <code>13</code>.</p> </li> <li> <p>Ligne <code>3</code> : On calcule d'abord la somme de la valeur de <code>total</code> (<code>0</code>) et de la valeur de <code>note</code> (<code>13</code>). On affecte ensuite le r\u00e9sultat (<code>13</code>) \u00e0 la variable <code>total</code>. L'ancienne valeur de <code>total</code> (<code>0</code>) est \u00e9cras\u00e9e par sa nouvelle valeur (<code>13</code>).</p> </li> <li> <p>Ligne <code>4</code> : Une nouvelle valeur est affect\u00e9e \u00e0 la variable <code>note</code>. L'ancienne valeur de <code>note</code> (<code>13</code>) est \u00e9cras\u00e9e par sa nouvelle valeur (<code>15</code>).</p> </li> <li> <p>Etc.</p> </li> </ul> Suivi de l'\u00e9volution de la valeur de variables <p>On peut repr\u00e9senter par un tableau les valeurs successives des variables au fur et \u00e0 mesure de l'ex\u00e9cution des lignes de code.</p> <p>Par exemple, pour le programme ci-dessus, voici le tableau obtenu :</p> Ligne <code>total</code> <code>note</code> <code>moyenne</code> Remarque 1 <code>0</code> La variable <code>total</code> est initialis\u00e9e. 2 <code>0</code> <code>13</code> La variable <code>`note</code> est initialis\u00e9e. 3 <code>13</code> <code>13</code> La valeur de <code>total</code> est \u00e9cras\u00e9e et remplac\u00e9e par une nouvelle valeur. 4 <code>13</code> <code>15</code> La valeur de <code>note</code> est \u00e9cras\u00e9e et remplac\u00e9e par une nouvelle valeur. 5 <code>28</code> <code>15</code> La valeur de <code>total</code> est \u00e9cras\u00e9e et remplac\u00e9e par une nouvelle valeur. 6 <code>28</code> <code>8</code> La valeur de <code>note</code> est \u00e9cras\u00e9e et remplac\u00e9e par une nouvelle valeur. 7 <code>36</code> <code>8</code> La valeur de <code>total</code> est \u00e9cras\u00e9e et remplac\u00e9e par une nouvelle valeur. 8 <code>36</code> <code>8</code> <code>12.0</code> La variable <code>moyenne</code> est initialis\u00e9e. Exercice 1-02 : Suivi de l'\u00e9volution de la valeur de variables <p>Objectif : \u00c0 l'aide d'un tableau de valeurs, suivre l'\u00e9volution de la valeur de plusieurs variables au cours de l'ex\u00e9cution d'une s\u00e9quence d'affectations.</p> <p>\u00c9nonc\u00e9</p> <p>1. Repr\u00e9senter sous forme de tableau les valeurs successives des variables lors de l'ex\u00e9cution de la s\u00e9quence d'instructions suivante :</p> <pre><code>a = 3\nb = 7\na = a + b\nb = a - b\na = a - b\n</code></pre> <p>2. Quel effet est produit par l'ex\u00e9cution des lignes <code>3</code> \u00e0 <code>5</code> ?</p> Corrig\u00e9 <p>1.</p> Ligne de code <code>a</code> <code>b</code> <code>a = 3</code> 3 <code>b = 7</code> 3 7 <code>a = a + b</code> 10 7 <code>b = a - b</code> 10 3 <code>a = a - b</code> 7 3 <p>2. L'ex\u00e9cution des lignes <code>3</code> \u00e0 <code>5</code> entra\u00eene un \u00e9change des valeurs des variables <code>a</code> et <code>b</code>.</p>"}, {"location": "constr_elem/#tutor-magic", "title": "Tutor Magic", "text": "<p>Tutor Magic est un outil qui permet, dans un carnet Jupyter, de suivre pas \u00e0 pas la valeur des variables pendant l'ex\u00e9cution d'une s\u00e9quence d'instructions.</p> <p>Il faut commencer par charger Tutor Magic en ex\u00e9cutant la commande suivante dans une cellule du carnet :</p> <pre><code>%load_ext tutormagic\n</code></pre> <p>Il suffit ensuite d'ajouter la ligne suivante au dessus de la s\u00e9quence d'instructions \u00e0 \u00e9tudier :</p> <pre><code>%%tutor --lang python3 --heapPrimitives\n</code></pre> <p>Voici le r\u00e9sultat obtenu :</p> <p></p> Activit\u00e9 1-03 : Utilisation de Tutor Magic <p>Objectif : Utiliser l'outil Tutor Magic.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "constr_elem/#partie-b-conditions-et-boucles", "title": "Partie B - Conditions et boucles", "text": "<p>Comme tous les langages de programmation imp\u00e9ratifs, Python dispose d'un ensemble de structures qui permettent d'ex\u00e9cuter des instructions de mani\u00e8re r\u00e9p\u00e9t\u00e9e ou lorsqu'un certain test est r\u00e9ussi. </p>"}, {"location": "constr_elem/#instructions-conditionnelles", "title": "Instructions conditionnelles", "text": "<p>On utilise une condition, ou instruction conditionnelle, lorsque les instructions \u00e0 ex\u00e9cuter d\u00e9pendent du r\u00e9sultat (<code>Vrai</code> ou <code>Faux</code>) d'un certain test.</p> <p>Par exemple, si la valeur de la variable <code>moyenne</code> est strictement inf\u00e9rieure \u00e0 <code>10</code>, on souhaite afficher \u00e0 l'\u00e9cran le message <code>\"\u00c9chec\"</code>.</p> <pre><code>moyenne = 9.6\nif moyenne &lt; 10:\n    print(\"\u00c9chec\")\n</code></pre> <p>La condition est introduite par le mot-cl\u00e9 <code>if</code>, qui est directement suivi par le test \u00e0 effectuer. La ligne se termine par <code>:</code>.</p> <p>Le test consiste \u00e0 v\u00e9rifier si oui ou non la valeur de la variable <code>moyenne</code> est strictement inf\u00e9rieure \u00e0 <code>10</code>.</p> <ul> <li> <p>Dans le cas o\u00f9 c'est vrai (<code>True</code> en Python), on ex\u00e9cute l'instruction <code>print(\"\u00c9chec\")</code>, qui provoque l'affichage demand\u00e9 \u00e0 l'\u00e9cran.</p> </li> <li> <p>Dans le cas o\u00f9 c'est faux (<code>False</code> en Python), l'instruction <code>print(\"\u00c9chec\")</code> n'est pas ex\u00e9cut\u00e9e, et rien ne s'affiche \u00e0 l'\u00e9cran.</p> </li> </ul> <p>Attention \u00e0 la virgule math\u00e9matique en Python</p> <p>La virgule math\u00e9matique est not\u00e9e par un <code>.</code> en Python. C'est la notation anglo-saxonne.</p> <p>On souhaite d\u00e9sormais que, dans le cas o\u00f9 la valeur de <code>moyenne</code> est strictement inf\u00e9rieure \u00e0 <code>10</code>, le message \"\u00c9chec\" s'affiche \u00e0 l'\u00e9cran mais que, dans le cas contraire, le message \"Succ\u00e8s\" s'affiche.</p> <pre><code>moyenne = 9.6\nif moyenne &lt; 10:\n    print(\"\u00c9chec\")\nelse:\n    print(\"Succ\u00e8s\")\n</code></pre> <p>Le mot-cl\u00e9 <code>else</code>, suivi de <code>:</code>, permet d'indiquer quelles sont les instructions \u00e0 ex\u00e9cuter dans le cas o\u00f9 le test est faux.</p> <p>On peut remarquer que, dans les exemples pr\u00e9c\u00e9dents, les instructions <code>print(\"\u00c9chec\")</code> et <code>print(\"Succ\u00e8s\")</code> sont d\u00e9cal\u00e9es horizontalement de quatre espaces vers la droite. On parle d'indentation. C'est un concept fondamental du langage Python, qu'on ne retrouve pas dans la grande majorit\u00e9 des autres langages de programmation.</p> <p>L'indentation est utilis\u00e9e pour signaler pr\u00e9cisement le d\u00e9but et la fin des s\u00e9quences d'instructions qui doivent \u00eatre ex\u00e9cut\u00e9es.</p> <p>Op\u00e9rateurs de comparaison</p> <p>Pour l'\u00e9criture des tests, on aura r\u00e9guli\u00e8rement recours aux op\u00e9rateurs math\u00e9matiques de comparaison :</p> <ul> <li><code>==</code> est \u00e9gal \u00e0,</li> <li><code>!=</code> n'est pas \u00e9gal \u00e0,</li> <li><code>&lt;</code> est strictement inf\u00e9rieur \u00e0,</li> <li><code>&gt;</code> est strictement sup\u00e9rieur \u00e0,</li> <li><code>&lt;=</code> est inf\u00e9rieur ou \u00e9gal \u00e0,</li> <li><code>&gt;=</code> est sup\u00e9rieur ou \u00e9gal \u00e0.</li> </ul> Exercice 1-04 : Instructions conditionnelles <p>Objectif : \u00c9crire des instructions conditionnelles.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "constr_elem/#boucle-bornee-boucle-pour", "title": "Boucle born\u00e9e (boucle pour)", "text": "<p>Lorsque l'on souhaite ex\u00e9cuter plusieurs fois de suite une m\u00eame s\u00e9quence d'instructions, et que l'on connait a priori le nombre de r\u00e9p\u00e9titions souhait\u00e9es, on utilise une boucle born\u00e9e.</p> <p>Par exemple, si on ex\u00e9cute la s\u00e9quence d'instructions suivantes :</p> <pre><code>for nombre in range(10):\n    carre = nombre * nombre\n    cube = nombre * nombre * nombre\n    print(\"Le carr\u00e9 du nombre\", nombre, \"est\", carre, \"et son cube est\", cube)\nprint(\"Ex\u00e9cution termin\u00e9e\")\n</code></pre> <p>alors l'affichage obtenu est :</p> <pre><code>Le carr\u00e9 du nombre 0 est 0 et son cube est 0\nLe carr\u00e9 du nombre 1 est 1 et son cube est 1\nLe carr\u00e9 du nombre 2 est 4 et son cube est 8\nLe carr\u00e9 du nombre 3 est 9 et son cube est 27\nLe carr\u00e9 du nombre 4 est 16 et son cube est 64\nLe carr\u00e9 du nombre 5 est 25 et son cube est 125\nLe carr\u00e9 du nombre 6 est 36 et son cube est 216\nLe carr\u00e9 du nombre 7 est 49 et son cube est 343\nLe carr\u00e9 du nombre 8 est 64 et son cube est 512\nLe carr\u00e9 du nombre 9 est 81 et son cube est 729\nEx\u00e9cution termin\u00e9e\n</code></pre> <p>La boucle pour est introduite par le mot-cl\u00e9 <code>for</code> et la premi\u00e8re ligne se termine par <code>:</code>.</p> <p>Sur les lignes <code>2</code> \u00e0 <code>4</code> est \u00e9crite la s\u00e9quence d'instructions \u00e0 ex\u00e9cuter plusieurs fois. Elle est indent\u00e9e.</p> <p>La ligne <code>5</code>, qui n'est pas indent\u00e9e, ne fait pas partie de la s\u00e9quence d'instructions \u00e0 r\u00e9p\u00e9ter. Elle n'est donc ex\u00e9cut\u00e9e qu'une seule fois, apr\u00e8s la fin de la boucle pour.</p> Visualisation \u00e0 l'aide de Tutor Magic <p></p> <p>\u00c0 propos de l'expression <code>range(10)</code></p> <p>L'expression <code>range(10)</code> permet de pr\u00e9ciser qu'on souhaite dix r\u00e9p\u00e9titions, pour tous les entiers <code>nombre</code> allant de <code>0</code> \u00e0 <code>9</code>.</p> <p>Lorsque la s\u00e9quence d'instructions est ex\u00e9cut\u00e9e pour la premi\u00e8re fois, la variable <code>nombre</code> a pour valeur <code>0</code>.</p> <p>Ensuite, la m\u00eame s\u00e9quence d'instructions est ex\u00e9cut\u00e9e \u00e0 nouveau, mais cette fois la variable <code>nombre</code> a pour valeur <code>1</code>.</p> <p>La s\u00e9quence est ensuite ex\u00e9cut\u00e9e alors que la variable <code>nombre</code> a pour valeur <code>2</code>, puis <code>3</code>, puis <code>4</code>, etc. jusqu'\u00e0 <code>9</code>.</p> Exercice 1-05 : Diff\u00e9rentes utilisations de <code>range</code> <p>Objectif : Comprendre comment s'utilise <code>range</code> dans l'\u00e9criture d'une boucle pour.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> Exercice 1-06 : Boucles born\u00e9es <p>Objectif : \u00c9crire des boucles born\u00e9es.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "constr_elem/#boucle-non-bornee-boucle-tant-que", "title": "Boucle non born\u00e9e (boucle tant que)", "text": "<p>Lorsque l'on souhaite ex\u00e9cuter plusieurs fois de suite une m\u00eame s\u00e9quence d'instructions, et que l'on ne connait pas a priori le nombre de r\u00e9p\u00e9titions souhait\u00e9es, on utilise une boucle non born\u00e9e.</p> <p>Par exemple, si on ex\u00e9cute la s\u00e9quence d'instructions suivantes :</p> <pre><code>nombre = 1\nwhile nombre &lt; 2000000:\n    print(nombre)\n    nombre = nombre * 16\nprint(\"Ex\u00e9cution termin\u00e9e\")\n</code></pre> <p>alors l'affichage obtenu est :</p> <pre><code>1\n16\n256\n4096\n65536\n1048576\nEx\u00e9cution termin\u00e9e\n</code></pre> <p>La boucle tant que est introduite par le mot-cl\u00e9 <code>while</code>, suivi d'une condition qui doit \u00eatre vraie pour que la s\u00e9quence d'instructions s'ex\u00e9cute. La premi\u00e8re ligne se termine par <code>:</code>.</p> <p>Sur les lignes <code>2</code> et <code>3</code> est \u00e9crite la s\u00e9quence d'instructions \u00e0 ex\u00e9cuter plusieurs fois, et elle est indent\u00e9e.</p> <p>La ligne <code>4</code>, qui n'est pas indent\u00e9e, ne fait pas partie de la s\u00e9quence d'instructions \u00e0 r\u00e9p\u00e9ter. Elle n'est donc ex\u00e9cut\u00e9e qu'une seule fois, apr\u00e8s la fin de la boucle tant que.</p> Visualisation \u00e0 l'aide de Tutor Magic <p></p> <p>Attention aux boucles infinies</p> <p>Il faut s'assurer que la condition qui d\u00e9finit la boucle tant que devient fausse \u00e0 un moment donn\u00e9. Dans le cas contraire, on parle de boucle infinie, et le programme ne fonctionne pas car on ne sort jamais de la boucle.</p> <pre><code>nombre = 1\nwhile nombre != 0:  # ATTENTION : BOUCLE INFINIE !\n    nombre = nombre + 1\nprint(\"Ex\u00e9cution termin\u00e9e\")  # Cette ligne ne sera jamais ex\u00e9cut\u00e9e\n</code></pre> <p>La variable <code>nombre</code> est initialis\u00e9e \u00e0 <code>1</code> et elle augmente ensuite d'une unit\u00e9 lors de chaque passage dans la boucle. Elle ne sera donc jamais \u00e9gale \u00e0 <code>0</code> et la boucle ne s'arr\u00eatera donc jamais.</p> Exercice 1-07 : Boucles non born\u00e9es <p>Objectif : \u00c9crire des boucles non born\u00e9es.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "constr_elem/#partie-c-exercices-et-activites", "title": "Partie C - Exercices et activit\u00e9s", "text": "Exercices 1-08 \u00e0 1-13 Exercice 1-08 : Plus grande valeurExercice 1-09 : Variables et bouclesExercice 1-10 : MandalaExercice 1-11 : Lancers d'un d\u00e9Exercice 1-12 : Carr\u00e9s color\u00e9s (1)Exercice 1-13 : Carr\u00e9s color\u00e9s (2) <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Corrig\u00e9 disponible ici</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Corrig\u00e9 disponible ici</p> Activit\u00e9s 1-14 \u00e0 1-16 Activit\u00e9 1-14 : Le jeu du nombre myst\u00e8reActivit\u00e9 1-15 : Une variante du jeu du PenduActivit\u00e9 1-16 : Le jeu du Juste prix <p>Objectifs :</p> <ul> <li>Utiliser des instructions conditionnelles et des boucles.</li> <li>D\u00e9couvrir la fonction permettant de tirer al\u00e9atoirement un nombre entier.</li> <li>D\u00e9couvrir la fonction permettant de demander \u00e0 l'utilisateur de faire une saisie au clavier.</li> </ul> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> <p>Objectif : Analyser un code et y rep\u00e9rer les variables, les affectations, les instructions conditionnelles et les boucles.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p> <p>Objectif : Mettre en \u0153uvre de nombreuses notions : variables et affectations, instructions conditionnelles, boucles, tirage d'entiers al\u00e9atoires, affichages \u00e0 l'\u00e9cran, saisies au clavier.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Corrig\u00e9 disponible ici</p>"}, {"location": "constr_elem/#ce-quil-faut-savoir-et-savoir-faire", "title": "Ce qu'il faut savoir et savoir faire", "text": "<ul> <li>Modifier et ex\u00e9cuter des cellules dans un carnet Jupyter.</li> <li>\u00c9crire une instruction conditionnelle.</li> <li>\u00c9crire une boucle born\u00e9e de la forme <code>for variable in range(nb_repetitions):</code>.</li> <li>\u00c9crire une boucle non born\u00e9e...</li> <li>... mais pas une boucle infinie.</li> <li>Utiliser correctement l'indentation pour d\u00e9finir les s\u00e9quences d'instructions.</li> <li>\u00catre capable de suivre la valeur d'une variable au cours de l'ex\u00e9cution d'une s\u00e9quence d'instructions, \u00e0 la main ou \u00e0 l'aide de Tutor Magic.</li> <li>Faire un affichage \u00e0 l'\u00e9cran avec la fonction <code>print</code>.</li> <li>Tirer un nombre entier au hasard avec la fonction <code>randint</code>.</li> <li>Demander \u00e0 l'utilisateur de saisir un entier au clavier avec la commande <code>int(input())</code>.</li> <li>Conna\u00eetre la diff\u00e9rence entre les expressions <code>range(a)</code>, <code>range(a, b)</code> et <code>range(a, b, c)</code>.</li> </ul>"}, {"location": "dictionnaires/", "title": "Chapitre 6 : p-uplets et dictionnaires", "text": "<p>Page en construction...</p> <p></p>"}, {"location": "flottants/", "title": "Chapitre 8 : Flottants", "text": ""}, {"location": "flottants/#partie-a-rappels-sur-lecriture-scientifique-des-nombres-decimaux", "title": "Partie A - Rappels sur l'\u00e9criture scientifique des nombres d\u00e9cimaux", "text": "<p>L'\u00e9criture scientifique d'un nombre d\u00e9cimal est compos\u00e9e de trois parties :</p> <ul> <li>un signe, qui peut \u00eatre plus ou moins,</li> <li>une mantisse, qui un nombre d\u00e9cimal compris entre \\(1\\) (inclus) et \\(10\\) (exclu),</li> <li>un exposant, qui est un nombre entier positif ou n\u00e9gatif.</li> </ul> <p>Par exemple, l'\u00e9criture scientifique du nombre \\(2030\\) est : \\(+ 2,03 \\times 10^3\\).</p> <p>Le signe est plus, la mantisse est \\(2,03\\) et l'exposant est \\(3\\).</p> <p>En Python, une fa\u00e7on d'afficher l'\u00e9criture scientifique d'un nombre <code>n</code> est d'utiliser la commande suivante :</p> <pre><code>print(\"{:e}\".format(n))\n</code></pre> <p>La mantisse s'affiche par d\u00e9faut avec six chiffres apr\u00e8s la virgule, mais il est possible d'en afficher davantage ou moins :</p> <pre><code>print(\"{:.2e}\".format(n))  # 2 chiffres apr\u00e8s la virgule pour la mantisse\nprint(\"{:.10e}\".format(n))  # 10 chiffres apr\u00e8s la virgule pour la mantisse\n</code></pre> <p>\\(0\\) n'a pas d'\u00e9criture scientifique</p> <p>On remarque qu'un nombre ne peut pas \u00eatre \u00e9crit dans ce format : le nombre \\(0\\). En effet, la mantisse devrait \u00eatre \u00e9gale \u00e0 \\(0\\), ce qui est exclu par d\u00e9finition.</p> Exercice 8-01 : \u00c9criture scientifique d\u00e9cimale <p>Objectif : D\u00e9terminer l'\u00e9criture scientifique d\u00e9cimale de nombres, \u00e0 la main et avec Python.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "flottants/#partie-b-ecriture-binaire-des-nombres", "title": "Partie B - \u00c9criture binaire des nombres", "text": ""}, {"location": "flottants/#rappel-concernant-les-nombres-entiers-positifs", "title": "Rappel concernant les nombres entiers positifs", "text": "<p>Donner l'\u00e9criture binaire d'un nombre entier positif, cela revient \u00e0 \u00e9crire ce nombre sous la forme d'une somme de puissances positives de \\(2\\).</p> <p>Par exemple, pour le nombre \\(2030\\) :</p> <p>\\(2030 = 1024 + 512 + 256 + 128 + 64 + 32 + 8 + 4 + 2\\) c'est-\u00e0-dire :</p> <p>\\(2030 = 2^{10} + 2^9 + 2^8 + 2^7 + 2^6 + 2^5 + 2^3 + 2^2 + 2^1\\) et l'\u00e9criture binaire de \\(2030\\) est donc :</p> <p>\\(2030 = (11111101110)_2\\).</p> <p>On peut v\u00e9rifier le r\u00e9sultat obtenu gr\u00e2ce \u00e0 la fonction <code>bin</code>, qui renvoie l'\u00e9criture binaire sous la forme d'une cha\u00eene de caract\u00e8res qui commence par <code>0b</code> :</p> <pre><code>print(bin(2030))  # affiche \"0b11111101110\"\n</code></pre> Exercice 8-02 : \u00c9criture binaire de nombres entiers positifs <p>Objectif : D\u00e9terminer l'\u00e9criture binaire de nombres entiers positifs, \u00e0 la main et avec Python.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "flottants/#ecriture-binaire-des-nombres-compris-entre-0-et-1", "title": "\u00c9criture binaire des nombres compris entre 0 et 1", "text": "<p>Le principe est le m\u00eame pour obtenir l'\u00e9criture binaire des nombres \u00e0 virgule. On s'autorise simplement d'utiliser aussi des puissances n\u00e9gatives de \\(2\\).</p> <p>Par exemple, pour le nombre \\(0,6875\\) : </p> <p>\\(0,6875 = 0,5 + 0,125 + 0,0625\\) c'est-\u00e0-dire :</p> <p>\\(0,6875 = 2^{-1} + 2^{-3} + 2^{-4}\\) et l'\u00e9criture binaire de \\(0,6875\\) est donc :</p> <p>\\(0,6875 = (0,1011)_2\\).</p> Exercice 8-03 : \u00c9criture binaire de nombres \u00e0 virgule <p>Objectif : D\u00e9terminer \u00e0 la main l'\u00e9criture binaire de nombres non entiers.</p> <p>\u00c9nonc\u00e9</p> <p>Donner l'\u00e9criture binaire des nombres \\(0,3125\\) et \\(0,515625\\).</p> <p>Remarquons que les nombres r\u00e9els qui ont une \u00e9criture d\u00e9cimale infinie ont aussi une \u00e9criture binaire infinie. Par exemple : </p> <p>\\(1/3 = 0,33333333... = (0,01010101...)_2\\).</p> <p>Il existe par contre des nombres r\u00e9els qui ont une \u00e9criture d\u00e9cimale finie mais qui ont une \u00e9criture binaire infinie. Par exemple : </p> <p>\\(1/5 = 0,2 = (0,00110011...)_2\\).</p> Exercice 8-04 : \u00c9criture binaire infinie <p>Objectif : D\u00e9terminer \u00e0 la main l'\u00e9criture binaire infinie d'un nombre.</p> <p>\u00c9nonc\u00e9</p> <p>Donner les 10 premiers bits apr\u00e8s la virgule de l'\u00e9criture binaire des nombres \\(0,1\\) et \\(0,3\\).</p>"}, {"location": "flottants/#partie-c-representation-des-flottants-en-machine-norme-ieee-754", "title": "Partie C - Repr\u00e9sentation des flottants en machine (norme IEEE 754)", "text": "<p>La norme informatique la plus couramment utilis\u00e9e pour repr\u00e9senter les nombres flottants est la norme IEEE 754 mise au point en 1985. Il s'agit d'une variante de l'\u00e9criture scientifique en base 2, dans laquelle la mantisse est un nombre compris entre \\(1\\) (inclus) et \\(2\\) (exclu).</p> <p>Les flottants peuvent \u00eatre repr\u00e9sent\u00e9s sur 32 bits (format dit de simple pr\u00e9cision) ou sur 64 bits (format dit de double pr\u00e9cision).</p> Format Signe <code>s</code> Exposant <code>e</code> Mantisse <code>m</code> Total simple pr\u00e9cision 1 bit 8 bits 23 bits 32 bits double pr\u00e9cision 1 bit 11 bits 52 bits 64 bits"}, {"location": "flottants/#principe-de-la-representation", "title": "Principe de la repr\u00e9sentation", "text": "<p>Le bit le plus \u00e0 gauche (bit de poids fort) correspond au signe du flottant :</p> <ul> <li><code>0</code> pour un flottant positif,</li> <li><code>1</code> pour un flottant n\u00e9gatif.</li> </ul> <p>Les 8 ou 11 bits suivants correspondent \u00e0 l'exposant <code>e</code>. Comme <code>e</code> peut \u00eatre positif ou n\u00e9gatif, on ne repr\u00e9sente pas directement l'entier <code>e</code> mais :</p> <ul> <li>l'entier <code>e + 127</code> sur 8 bits pour le format simple pr\u00e9cision,</li> <li>l'entier <code>e + 1023</code> sur 11 bits pour le format double pr\u00e9cision.</li> </ul> <p>Les 23 ou 52 derniers bits correspondent \u00e0 la mantisse <code>m</code>. Comme <code>m</code> est par d\u00e9finition compris entre \\(1\\) et \\(2\\), c'est uniquement la partie fractionnaire (partie situ\u00e9e apr\u00e8s la virgule) du nombre <code>m - 1</code> qui est repr\u00e9sent\u00e9e sur 23 ou 52 bits.</p>"}, {"location": "flottants/#exemple", "title": "Exemple", "text": "<p>Repr\u00e9sentons par exemple sur 32 bits le nombre flottant <code>-0,2</code>. Il est n\u00e9gatif donc le bit le plus \u00e0 gauche de sa repr\u00e9sentation est un <code>1</code>.</p> <p>De plus, nous avons vu pr\u00e9c\u00e9demment que \\(0,2 = (0,00110011...)_2 = (1,10011001...)_2 \\times 2^{-3}\\). L'exposant <code>e</code> est donc \\(-3\\) et la mantisse <code>m</code> est $1,10011001 ... $.</p> <p>On \u00e9crit sur 8 bits le nombre <code>e + 127</code> (c'est-\u00e0-dire 124) ce qui donne <code>01111100</code>.</p> <p>Enfin, on \u00e9crit sur 23 bits la partie fractionnaire de <code>m-1</code> (c'est-\u00e0-dire \\(0,10011001...\\)) ce qui donne <code>10011001100110011001100(1)</code>, arrondi \u00e0 <code>10011001100110011001101</code>.</p> <p>La repr\u00e9sentation sur 32 bits obtenue pour le flottant <code>-0,2</code> est donc <code>1 01111100 10011001100110011001101</code>.</p> <p>Repr\u00e9sentation du nombre \\(0\\)</p> <p>Nous avons dit que le nombre \\(0\\) n'a pas d'\u00e9criture scientifique. Il est par convention repr\u00e9sent\u00e9 par <code>0 00000000 00000000000000000000000</code> sur 32 bits.</p> Exercice 8-05 : Repr\u00e9sentation de flottants sur 32 bits <p>Objectif : D\u00e9terminer \u00e0 la main la repr\u00e9sentation sur 32 bits d'un nombre flottant.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "flottants/#partie-d-probleme-du-test-degalite-de-deux-flottants", "title": "Partie D - Probl\u00e8me du test d'\u00e9galit\u00e9 de deux flottants", "text": "<p>La repr\u00e9sentation des nombres flottants en machine est approximative lorsque leur \u00e9criture binaire est infinie ou compos\u00e9e de trop de bits apr\u00e8s la virgule.</p> <p>Par exemple, les nombres \\(0,1\\) et \\(0,2\\) ont une \u00e9criture binaire infinie, d'o\u00f9 les probl\u00e8mes d'arrondis qui font que l'expression bool\u00e9enne <code>0.1 + 0.2 == 0.3</code> vaut <code>False</code>.</p> <p>C'est la raison pour laquelle il faut absolument \u00e9viter d'utiliser des conditions dans lesquelles on teste l'\u00e9galit\u00e9 entre deux flottants.</p> <p>Il est fortement recommand\u00e9 de remplacer un test d'\u00e9galit\u00e9 <code>flottant1 == flottant2</code> par un test du type <code>abs(flottant1 - flottant2) &lt; 10**-n</code> qui est un test d'\u00e9galit\u00e9 approch\u00e9e (avec <code>n</code> chiffres apr\u00e8s la virgule de pr\u00e9cision).</p> Exercice 8-06 : Probl\u00e8mes d'arrondis lors du calcul sur les flottants <p>Objectifs :</p> <ul> <li>Constater sur des exemples les probl\u00e8mes provoqu\u00e9s par la repr\u00e9sentation approximative des flottants en machine.</li> <li>Utiliser des tests d'\u00e9galit\u00e9 approch\u00e9e.</li> </ul> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "flottants/#partie-e-exercices", "title": "Partie E - Exercices", "text": "Exercices 8-07 et 8-08 Exercice 8-07 : Repr\u00e9sentation sur 32 bitsExercice 8-08 : Arrondis sur les flottants <p>\u00c9nonc\u00e9</p> <p>1. Donner la valeur d\u00e9cimale du nombre flottant dont la repr\u00e9sentation sur 32 bits est : <code>1 01111110 11110000000000000000000</code>.</p> <p>2. M\u00eame question pour le nombre flottant dont la repr\u00e9sentation sur 32 bits est : <code>0 10000011 11100000000000000000000</code>.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "flottants/#ce-quil-faut-savoir-et-savoir-faire", "title": "Ce qu'il faut savoir et savoir faire", "text": "<ul> <li>Donner l'\u00e9criture scientifique d\u00e9cimale d'un nombre.</li> <li>Afficher l'\u00e9criture scientifique d\u00e9cimale d'un nombre <code>n</code> avec la commande <code>print(\"{:e}\".format(n))</code></li> <li>D\u00e9terminer l'\u00e9criture binaire d'un entier positif.</li> <li>Afficher l'\u00e9criture binaire d'un entier avec la fonction <code>bin</code>.</li> <li>D\u00e9terminer l'\u00e9criture binaire d'un nombre d\u00e9cimal positif.</li> <li>D\u00e9terminer la repr\u00e9sentation d'un nombre flottant sur 32 bits.</li> <li>Retrouver un flottant \u00e0 partir de sa repr\u00e9sentation sur 32 bits.</li> <li>Ne pas utiliser de test d'\u00e9galit\u00e9 sur les flottants, mais des tests d'\u00e9galit\u00e9 approch\u00e9e.</li> </ul>"}, {"location": "fonctions/", "title": "Chapitre 3 : Fonctions", "text": ""}, {"location": "fonctions/#partie-a-appel-et-definition-dune-fonction", "title": "Partie A - Appel et d\u00e9finition d'une fonction", "text": ""}, {"location": "fonctions/#appel-dune-fonction", "title": "Appel d'une fonction", "text": "Activit\u00e9 3-01 : D\u00e9partements de la r\u00e9gion \u00cele-de-France <p>Objectif : Comprendre comment faire appel \u00e0 une fonction.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>L'activit\u00e9 introductive nous fait utiliser deux fonctions :</p> <ul> <li>La premi\u00e8re, <code>nom_departement</code>, renvoie le nom d'un d\u00e9partement de la r\u00e9gion \u00cele-de-France \u00e0 partir de son num\u00e9ro.</li> <li>La seconde, <code>prefecture</code>, renvoie le nom du chef lieu d'un d\u00e9partement de la r\u00e9gion \u00cele-de-France \u00e0 partir de son num\u00e9ro.</li> </ul> <p>Les appels <code>nom_departement(94)</code> et <code>prefecture(94)</code> sont des expressions dont la valeur est d\u00e9termin\u00e9e et renvoy\u00e9e par la fonction. Ces expressions peuvent bien entendu \u00eatre affect\u00e9es \u00e0 des variables.</p> <p>La valeur <code>94</code> \u00e9crite entre parenth\u00e8ses apr\u00e8s le nom des deux fonctions s'appelle un argument. En changeant l'argument d'une fonction, son appel peut produire un r\u00e9sultat diff\u00e9rent.</p> <pre><code>numero = 94\nnom = nom_departement(numero)\nville = prefecture(numero)\nprint(\"Le d\u00e9partement\", numero, \"s'appelle\", nom, \"et sa pr\u00e9fecture est\", ville)\n</code></pre> <p>Par exemple, l'ex\u00e9cution du programme ci-dessus entra\u00eene l'affichage de la phrase <code>Le d\u00e9partement 94 s'appelle Val-de-Marne et sa pr\u00e9fecture est Cr\u00e9teil</code>.</p> <pre><code>numero = 93\nnom = nom_departement(numero)\nville = prefecture(numero)\nprint(\"Le d\u00e9partement\", numero, \"s'appelle\", nom, \"et sa pr\u00e9fecture est\", ville)\n</code></pre> <p>Par contre, l'ex\u00e9cution du programme ci-dessus entra\u00eene l'affichage de la phrase <code>Le d\u00e9partement 93 s'appelle Seine Saint Denis et sa pr\u00e9fecture est Bobigny</code>.</p>"}, {"location": "fonctions/#definition-dune-fonction", "title": "D\u00e9finition d'une fonction", "text": "<p>Nous souhaitons maintenant d\u00e9finir une fonction <code>nom_academie</code>, qui renvoie le nom de l'acad\u00e9mie dont fait partie un d\u00e9partement d\u00e9sign\u00e9 par son num\u00e9ro. On rappelle que les trois acad\u00e9mies d'\u00cele-de-France sont compos\u00e9es de la fa\u00e7on suivante :</p> Acad\u00e9mie de Cr\u00e9teil Acad\u00e9mie de Paris Acad\u00e9mie de Versailles 77 - 93 - 94 75 78 - 91 - 92 - 95 <pre><code>def nom_academie(num):\n    if num == 75:\n        ac = \"Acad\u00e9mie de Paris\"\n    elif num == 77 or num == 93 or num == 94:\n        ac = \"Acad\u00e9mie de Cr\u00e9teil\"\n    else:\n        ac = \"Acad\u00e9mie de Versailles\"\n    return ac\n</code></pre> <p>Lors qu'on d\u00e9finit une fonction, la premi\u00e8re ligne commence toujours par le mot cl\u00e9 <code>def</code>, suivi du nom de la fonction, et se termine par un couple de parenth\u00e8ses suivi de deux points.</p> <p>\u00c0 l'int\u00e9rieur des parenth\u00e8ses, on fait appara\u00eetre le ou les \u00e9ventuel(s) param\u00e8tre(s) d'entr\u00e9e de la fonction. Il s'agit de variables locales, qui n'existent dans la m\u00e9moire que pendant l'ex\u00e9cution de la fonction, et qui ont pour valeur un argument fix\u00e9 au moment de l'appel de la fonction. Par exemple, pour la fonction <code>nom_academie</code>, il y a un seul param\u00e8tre d'entr\u00e9e <code>num</code>, qui correspond \u00e0 un num\u00e9ro de d\u00e9partement.</p> <p>Sous la premi\u00e8re ligne figure la s\u00e9quence d'instructions qui est ex\u00e9cut\u00e9e lors de l'appel de la fonction. Cette s\u00e9quence s'ex\u00e9cute soit jusqu'\u00e0 la fin, soit jusqu'\u00e0 l'instruction <code>return variable_ou_expression</code> (qui stoppe toujours l'ex\u00e9cution de la fonction dans laquelle elle se trouve). C'est cette instruction qui permet de renvoyer une valeur, appel\u00e9e param\u00e8tre de sortie, qui est conserv\u00e9e dans la m\u00e9moire pour la suite de l'ex\u00e9cution du programme. Par exemple, pour la fonction <code>nom_academie</code>, il y a un param\u00e8tre de sortie <code>ac</code>, qui correspond au nom de l'acad\u00e9mie dans laquelle se trouve le d\u00e9partement num\u00e9ro <code>num</code>.</p> <p>Attention \u00e0 ne pas confondre d\u00e9finition et appel de fonction</p> <p>Lorsqu'on se contente d'\u00e9crire la d\u00e9finition d'une fonction, aucune ex\u00e9cution de la fonction n'est r\u00e9alis\u00e9e. C'est seulement lors d'un appel \u00e0 la fonction que les instructions correspondantes sont ex\u00e9cut\u00e9es.</p> Exercice 3-02 : D\u00e9finition de fonctions simples <p>Objectif : D\u00e9finir et tester des fonctions simples tout en retravaillant les instructions conditionnelles et les boucles.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> Activit\u00e9 3-03 : Retour sur la suite de Syracuse <p>Objectif : Poursuivre l'\u00e9tude de la suite de Syracuse, vue au chapitre pr\u00e9c\u00e9dent, dans le but d'\u00e9crire et de tester des fonctions.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "fonctions/#cas-particulier-des-procedures", "title": "Cas particulier des proc\u00e9dures", "text": "<p>Une proc\u00e9dure est une fonction qui ne renvoie aucune valeur, et ne poss\u00e8de donc pas de param\u00e8tre de sortie. Elle peut, en revanche, poss\u00e9der un ou plusieurs param\u00e8tres d'entr\u00e9e.</p> Exercice 3-04 : Jeu du retournement <p>Objectif : Identifier dans un programme quelles sont les fonctions et quelles sont les proc\u00e9dures.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p>"}, {"location": "fonctions/#partie-b-specification-dune-fonction", "title": "Partie B - Sp\u00e9cification d'une fonction", "text": "<p>La sp\u00e9cification d'une fonction permet de conna\u00eetre son r\u00f4le et ses \u00e9ventuels param\u00e8tres d'entr\u00e9e, param\u00e8tre de sortie et effets de bord.</p> <p>Cela permet de savoir \u00e0 quoi sert une fonction, comment l'utiliser (quelles entr\u00e9es ? quelle sortie ?) et quels sont ses effets secondaires \u00e9ventuels sur la machine (par exemple la modification d'une variable globale en m\u00e9moire, un affichage \u00e0 l'\u00e9cran, l'\u00e9criture dans un fichier, ...).</p> <p>Consid\u00e9rons par exemple la fonction suivante, et donnons sa sp\u00e9cification :</p> <pre><code>def aire_triangle(a, b, c):\n    if a == b and b == c:  # Les trois c\u00f4t\u00e9s sont de m\u00eame longueur\n        print(\"Triangle \u00e9quilat\u00e9ral !\")\n    elif a == b or b == c or c == a:  # Deux des trois c\u00f4t\u00e9s sont de m\u00eame longueur\n        print(\"Triangle isoc\u00e8le !\")\n    demi_perimetre = (a + b + c) / 2\n    aire = (demi_perimetre * (demi_perimetre - a) * (demi_perimetre - b) * (demi_perimetre - c)) ** 0.5\n    return aire\n</code></pre> <ul> <li>R\u00f4le de la fonction : Affiche \u00e0 l'\u00e9cran si le triangle est \u00e9quilat\u00e9ral ou isoc\u00e8le, et renvoie son aire.</li> <li>Param\u00e8tres d'entr\u00e9e : <code>a</code>, <code>b</code>, <code>c</code> (nombres), les longueurs des trois c\u00f4t\u00e9s du triangle.</li> <li>Param\u00e8tre de sortie : <code>aire</code> (nombre), l'aire du triangle (calcul\u00e9e gr\u00e2ce \u00e0 la formule de H\u00e9ron).</li> <li>Effets de bord : Affichage \u00e0 l'\u00e9cran dans le cas o\u00f9 le triangle est \u00e9quilat\u00e9ral ou isoc\u00e8le.</li> </ul> <p>La sp\u00e9cification d'une fonction s'\u00e9crit en Python dans une zone (appel\u00e9e docstring) d\u00e9limit\u00e9e par trois guillemets doubles <code>\"\"\"</code> et situ\u00e9e juste au dessous de la ligne commen\u00e7ant par <code>def</code>.</p> <p>On fait appara\u00eetre successivement le r\u00f4le de la fonction, puis ses param\u00e8tres d'entr\u00e9e, son param\u00e8tre de sortie et ses effets de bord s'il y en a.</p> <pre><code>def aire_triangle(a, b, c):\n\"\"\"\n    Affiche \u00e0 l'\u00e9cran si le triangle est \u00e9quilat\u00e9ral ou isoc\u00e8le, et renvoie son aire.\n    - Entr\u00e9es : a, b, c (nombres)\n    - Sortie : aire (nombre)\n    Effet de bord : affichage \u00e9ventuel \u00e0 l'\u00e9cran\n    \"\"\"\n    if a == b and b == c:  # Les trois c\u00f4t\u00e9s sont de m\u00eame longueur\n        print(\"Triangle \u00e9quilat\u00e9ral !\")\n    elif a == b or b == c or c == a:  # Deux des trois c\u00f4t\u00e9s sont de m\u00eame longueur\n        print(\"Triangle isoc\u00e8le !\")\n    demi_perimetre = (a + b + c) / 2\n    aire = (demi_perimetre * (demi_perimetre - a) * (demi_perimetre - b) * (demi_perimetre - c)) ** 0.5\n    return aire\n</code></pre> <p>Attention aux sp\u00e9cifications</p> <p>Toutes les fonctions et proc\u00e9dures que vous d\u00e9finirez devront d\u00e9sormais avoir leur sp\u00e9cification. Cela permettra de rendre votre code plus clair, en explicitant le r\u00f4le de chaque fonction ou proc\u00e9dure et les param\u00e8tres qu'elle utilise, mais aussi plus facile \u00e0 corriger dans le cas o\u00f9 il contiendrait des erreurs.</p> <p>La fonction <code>help</code> permet d'acc\u00e9der \u00e0 la docstring de la fonction dont le nom est pass\u00e9 en param\u00e8tre d'entr\u00e9e.</p> Exercice 3-05 : Proc\u00e9dure <code>etoile</code> <p>Objectif : \u00c9crire la sp\u00e9cification d'une proc\u00e9dure apr\u00e8s l'avoir test\u00e9e.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p>"}, {"location": "fonctions/#partie-c-assertions", "title": "Partie C - Assertions", "text": "<p>Lors d'un appel de fonction, il faut souvent s'assurer que les arguments pass\u00e9s en param\u00e8tre d'entr\u00e9e sont acceptables, tant au niveau de leur type que de leur valeur. On utilise pour cela des assertions.</p> <p>On peut par exemple remarquer que la proc\u00e9dure <code>etoile</code> d\u00e9finie pr\u00e9c\u00e9demment ne fonctionne correctement que si son param\u00e8tre d'entr\u00e9e <code>nb_branches</code> est un entier impair.</p> <p>En Python, il existe deux fa\u00e7ons de mettre en place une assertion :</p> <ul> <li>avec le mot-cl\u00e9 <code>assert</code>, \u00e0 privil\u00e9gier pour le d\u00e9bogage des fonctions que vous serez le seul ou la seule \u00e0 utiliser.</li> <li>avec le mot-cl\u00e9 <code>raise</code>, \u00e0 privil\u00e9gier dans le cas o\u00f9 les fonctions seraient mises \u00e0 la disposition d'autres que vous.</li> </ul>"}, {"location": "fonctions/#assertions-avec-le-mot-cle-assert", "title": "Assertions avec le mot-cl\u00e9 <code>assert</code>", "text": "<p>La syntaxe est la suivante : <code>assert condition, message_d_erreur</code>.</p> <p>Si la <code>condition</code> est fausse, l'ex\u00e9cution de la fonction s'interrompt et le <code>message_d_erreur</code> s'affiche.</p> <p>Pour v\u00e9rifier que <code>nb_branches</code> est un entier, la condition s'\u00e9crit <code>type(nb_branches) == int</code>. C'est une v\u00e9rification de type.</p> <p>Pour v\u00e9rifier que <code>nb_branches</code> est impair, la condition s'\u00e9crit <code>nb_branches % 2 != 0</code>. C'est une v\u00e9rification de valeur.</p> <pre><code>def etoile(nb_branches, longueur):\n    assert type(nb_branches) == int, \"le premier argument doit \u00eatre un entier\"\n    assert nb_branches % 2 != 0, \"le premier argument doit \u00eatre impair\"\n    clear()\n    angle = 180 * (1 - 1 / nb_branches)\n    for n in range(nb_branches):\n        forward(longueur)\n        left(angle)\n</code></pre> <p>L'appel <code>etoile(\"bonjour\", 300)</code> entra\u00eene l'erreur suivante :</p> <pre><code>AssertionError: le premier argument doit \u00eatre un entier\n</code></pre> <p>L'appel <code>etoile(6, 300)</code> entra\u00eene l'erreur suivante :</p> <pre><code>AssertionError: le premier argument doit \u00eatre impair\n</code></pre> <p>Utilisation de la fonction <code>type</code></p> <p>La fonction <code>type</code> renvoie le type de la variable ou de l'expression qui lui est pass\u00e9e en param\u00e8tre. Les principaux types que nous utiliserons cette ann\u00e9e sont list\u00e9s dans le tableau suivant :</p> Notation Python Type Exemples <code>int</code> Nombre entier <code>0</code> <code>-1023</code> <code>7*9+2</code> <code>10**9</code> <code>int(3.1)</code> <code>float</code> Nombre flottant <code>0.0</code> <code>-10.23</code> <code>6/3</code> <code>10**-9</code> <code>float(3)</code> <code>bool</code> Bool\u00e9en <code>True</code> <code>False</code> <code>True or False</code> <code>2 &lt;= 0</code> <code>bool(1)</code> <code>function</code> Fonction ou proc\u00e9dure <code>print</code> <code>input</code> <code>nom_departement</code> <code>aire_triangle</code> <code>etoile</code> <code>str</code> Cha\u00eene de caract\u00e8res voir chap. 4 <code>list</code> Tableau voir chap. 5 <code>tuple</code> p-uplet voir chap. 6 <code>dict</code> Dictionnaire voir chap. 6 Exercice 3-06 : Assertions avec <code>assert</code> <p>Objectif : \u00c9crire des assertions avec le mot-cl\u00e9 <code>assert</code>.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "fonctions/#assertions-avec-le-mot-cle-raise", "title": "Assertions avec le mot-cl\u00e9 <code>raise</code>", "text": "<p>Le mot-cl\u00e9 <code>raise</code> s'utilise \u00e0 l'int\u00e9rieur d'une instruction conditionnelle.</p> <p>La syntaxe est la suivante : <code>raise Exception(message_d_erreur)</code>.</p> <p>Si la commande est ex\u00e9cut\u00e9e, la fonction s'interrompt et le <code>message_d_erreur</code> s'affiche.</p> <p>Le mot-cl\u00e9 <code>Exception</code> peut, par exemple, \u00eatre remplac\u00e9 :</p> <ul> <li>par <code>TypeError</code> dans le cas d'une erreur de type.</li> <li>par <code>ValueError</code> dans le cas d'une erreur de valeur.</li> </ul> <pre><code>def etoile(nb_branches, longueur):\n    if type(nb_branches) != int:\n        raise TypeError(\"le premier argument doit \u00eatre un entier\")\n    if nb_branches % 2 == 0:\n        raise ValueError(\"le premier argument doit \u00eatre impair\")\n    clear()\n    angle = 180 * (1 - 1 / nb_branches)\n    for n in range(nb_branches):\n        forward(longueur)\n        left(angle)\n</code></pre> <p>L'appel <code>etoile(\"bonjour\", 300)</code> entra\u00eene l'erreur suivante :</p> <pre><code>TypeError: le premier argument doit \u00eatre un entier\n</code></pre> <p>L'appel <code>etoile(6, 300)</code> entra\u00eene l'erreur suivante :</p> <pre><code>ValueError: le premier argument doit \u00eatre impair\n</code></pre> Exercice 3-07 : Assertions avec <code>raise</code> <p>Objectif : \u00c9crire des assertions avec le mot-cl\u00e9 <code>raise</code>.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "fonctions/#partie-d-exercices-et-activites", "title": "Partie D - Exercices et activit\u00e9s", "text": "Exercices 3-08 \u00e0 3-10 Exercice 3-08 : Th\u00e9or\u00e8me de PythagoreExercice 3-09 : Suite d'entiersExercice 3-10 : Nombre de jours <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p> Activit\u00e9s 3-11 et 3-12 Activit\u00e9 3-11 : Triangles et carr\u00e9sActivit\u00e9 3-12 : Carte de vigilance m\u00e9t\u00e9orologique <p>Objectif : D\u00e9finir des proc\u00e9dures pour r\u00e9aliser des dessins g\u00e9om\u00e9triques.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Objectif : Utiliser des fonctions et proc\u00e9dures pour repr\u00e9senter des donn\u00e9es sur une carte.</p> <p>Carnet Jupyter \u00e0 t\u00e9l\u00e9charger ici</p> <p>Carnet Jupyter accessible sur CAPYTALE</p>"}, {"location": "fonctions/#ce-quil-faut-savoir-et-savoir-faire", "title": "Ce qu'il faut savoir et savoir faire", "text": "<ul> <li>Appeler une fonction.</li> <li>D\u00e9finir une fonction, avec param\u00e8tres d'entr\u00e9e \u00e9ventuels et param\u00e8tre de sortie.</li> <li>Tester une fonction, et v\u00e9rifier que le r\u00e9sultat obtenu est coh\u00e9rent.</li> <li>Faire la diff\u00e9rence entre variable globale et variable locale associ\u00e9e \u00e0 une fonction.</li> <li>Faire la diff\u00e9rence entre une fonction et une proc\u00e9dure.</li> <li>\u00c9crire ou comprendre la sp\u00e9cification d'une fonction.</li> <li>\u00c9crire une assertion avec le mot-cl\u00e9 <code>assert</code>.</li> <li>\u00c9crire une assertion avec le mot-cl\u00e9 <code>raise</code>.</li> <li>Utiliser la fonction <code>type</code>.</li> <li>Utiliser la fonction <code>help</code> pour obtenir la sp\u00e9cification d'une fonction.</li> <li>Utiliser quelques proc\u00e9dures du module <code>Turtle</code>, dont <code>forward</code>, <code>left</code>, <code>right</code>, <code>goto</code>, <code>up</code> et <code>down</code>.</li> </ul>"}, {"location": "tableaux/", "title": "Chapitre 5 : Tableaux", "text": "<p>Page en construction...</p> <p></p>"}, {"location": "tables/", "title": "Chapitre 7 : Tables de donn\u00e9es", "text": "<p>Page en construction...</p> <p></p>"}]}